#!/usr/bin/python

# Hello, I am Pieman! Defender of the innocent! Propagator of political
# discontent! Occasional dog walker.
#
# Er, anyway, here's man for Python.

import inspect, re, sys

STATEMENTS = frozenset(['assert', 'break', 'continue', 'del', 'exec', 'global',
    'import', 'pass', 'print', 'raise', 'return', 'yield'])

def signature(name, argspec):
    args = []
    defaults = argspec[3]
    for i, arg in enumerate(argspec[0]):
        if defaults is not None and len(argspec[0]) - i <= len(defaults):
            args.append('%s=%s' % (arg, defaults[i + len(defaults) - len(argspec[0])]))
        else:
            args.append(arg)
    if argspec[1] is not None:
        args.append('*%s' % argspec[1])
    if argspec[2] is not None:
        args.append('**%s' % argspec[2])
    return '%s(%s)' % (name, ', '.join(args))

def main(argv):
    if len(argv) < 2 or argv[1] == '--help':
        print >>sys.stderr, 'Usage: %s function' % argv[0]
        return -1

    call = argv[1]

    if call in STATEMENTS:
        print >>sys.stdout, '\'%s\' is a statement; refer to online ' \
            'documentation' % call
        return 0

    # If there's a period in the path, the first component indicates the module
    # in which this function is contained.
    module = None
    if '.' in call:
        m, call = call.split('.', 1)
        try:
            module = __import__(m)
        except Exception as e:
            print >>sys.stderr, 'Failed to import \'%s\'' % m
            return -1

    # Now the function could be either (a) a built-in, (b) a global function,
    # (c) a module itself or (d) a function in a module.
    fn = None
    if module is None:
        try:
            fn = getattr(__builtins__, call) # (a)
        except AttributeError:
            try:
                fn = globals()[call] # (b)
            except KeyError:
                try:
                    fn = __import__(call) # (c)
                except ImportError:
                    pass
    else: # (d)
        try:
            bits = call.split('.')
            for b in bits:
                if fn is None:
                    fn = getattr(module, b)
                else:
                    fn = getattr(fn, b)
        except AttributeError:
            pass
    if fn is None:
        print >>sys.stderr, 'Failed to find \'%s\'' % argv[1]
        return -1

    try:
        doc = fn.__doc__
        if doc is None:
            raise AttributeError
    except AttributeError:
        print >>sys.stderr, 'No documentation associated with \'%s\'' % argv[1]
        return -1

    if inspect.isfunction(fn):
        print signature(fn.__name__, inspect.getargspec(fn))
        print ''
    elif inspect.isclass(fn):
        print signature('%s.__init__' % fn.__name__, inspect.getargspec(fn.__init__))
        print ''
    print re.sub(r'^    ', '', doc, flags=re.MULTILINE)

    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))
