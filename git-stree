#!/usr/bin/env python

'''
This is a work in progress. Don't run it unless you are prepared for explosions.
'''

import argparse, atexit, json, os, re, subprocess, sys, uuid

class Remote(object):
    def __init__(self, remote, branch):
        self.remote = remote
        self.branch = branch

def get_remotes(root):
    remotes = subprocess.check_output(['git', 'remote', '-v'], cwd=root)
    regex = re.compile(r'(?P<name>[^\s]+)\s+(?P<url>[^\s]+)\s+\(fetch\)$')
    d = {}
    for line in (x.strip() for x in remotes.split('\n')):
        m = regex.match(line)
        if m is not None:
            d[m.group('name')] = m.group('url')
    return d

def add_remote(root, name, url):
    subprocess.check_call(['git', 'remote', 'add', name, url], cwd=root)

def remove_remote(root, name):
    subprocess.check_call(['git', 'remote', 'remove', name], cwd=root)

def new_transient_remote(root, url):
    name = str(uuid.uuid4())
    add_remote(root, name, url)
    atexit.register(remove_remote, root, name)
    return name

def fetch(root, remote, branch='master'):
    with open(os.devnull, 'w') as f:
        subprocess.check_call(['git', 'fetch', remote, branch], cwd=root,
            stdout=f, stderr=f)

def diff(root, remote, branch, prefix):
    return subprocess.check_output(['git', 'diff', '%s/%s' % (remote, branch),
        '%s:%s' % (branch, prefix)], cwd=root)

def main(argv):
    parser = argparse.ArgumentParser(description='git subtree helper')
    parser.add_argument('command', choices=('diff',), help='command to run')
    parser.add_argument('--input', '-i', type=argparse.FileType('r'),
        default=os.path.join(os.getcwd(), '.subtree.json'),
        help='subtree list')
    parser.add_argument('--prefix', '-p', action='append',
        help='subtree to act on (default: all)')
    options = parser.parse_args(argv[1:])

    # Load definition of subtrees.
    try:
        items = json.load(options.input)
    except ValueError as e:
        sys.stderr.write('could not parse %s: %s\n' % (options.input.name, e))
        return -1
    if not isinstance(items, list):
        sys.stderr.write('malformed JSON: input is not a list\n')
        return -1

    subtrees = {}
    root = os.path.dirname(options.input.name)

    # Valid the JSON and build up our knowledge of subtrees.
    for index, i in enumerate(items):
        if not isinstance(i, dict):
            sys.stderr.write('malformed JSON: item %d is not a dict\n' % index)
            return -1
        prefix = i.get('prefix')
        if prefix is None:
            sys.stderr.write('malformed JSON: item %d has no prefix\n' % index)
            return -1
        remote = i.get('remote')
        if remote is None:
            sys.stderr.write('malformed JSON: item %d has no remote\n' % index)
            return -1
        if prefix in subtrees:
            sys.stderr.write('malformed JSON: prefix %s appears twice\n' %
                prefix)
            return -1
        subtrees[prefix] = Remote(remote, i.get('branch', 'master'))

    # Check all prefixes exist.
    for p in options.prefix or ():
        if p not in subtrees:
            sys.stderr.write('prefix %s is not defined in %s\n' %
                (p, options.input.name))
            return -1

    try:
        remotes = get_remotes(root)
    except subprocess.CalledProcessError:
        return -1

    for prefix in options.prefix or ():
        assert prefix in subtrees
        s = subtrees[prefix]
        remote = None
        for name, url in remotes.items():
            if s.remote == url:
                remote = name
                break
        if remote is None:
            try:
                remote = new_transient_remote(root, s.remote)
            except subprocess.CalledProcessError:
                sys.stderr.write('failed while creating transient remote for '
                    '%s\n' % s.remote)
                return -1
            remotes[remote] = s.remote
        try:
            fetch(root, remote, s.branch)
        except subprocess.CalledProcessError:
            sys.stderr.write('failed to fetch from remote %s\n' % s.remote)
            return -1
        try:
            sys.stdout.write(diff(root, remote, s.branch, prefix))
        except subprocess.CalledProcessError:
            sys.stderr.write('failed to diff at prefix for %s\n' % s.remote)
            return -1

    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))
