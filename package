#!/usr/bin/env python

import argparse, cStringIO, functools, os, shutil, subprocess, sys, tarfile, threading, \
  uuid

# Import Python LZMA (a.k.a. 7-zip) if we have it.
try:
    import lzma
except ImportError:
    lzma = None

# Test if we have GPG.
try:
    with open(os.devnull, 'w') as devnull:
        subprocess.check_call(['gpg', '--version'], stdout=devnull,
            stderr=devnull)
    gpg = 'gpg'
except subprocess.CalledProcessError:
    gpg = None

class Archiver(threading.Thread):
    def __init__(self, destination, members):
        if not isinstance(destination, file):
            raise TypeError
        if not isinstance(members, list) or not all(map(lambda x: isinstance(x, str), members)):
            raise TypeError
        super(Archiver, self).__init__()
        self.destination = destination
        self.members = members

    def run(self):
        # XXX: tarfile doesn't support writing to non-seekable pipes, so we
        # need to go via a StringIO.
        buffer = cStringIO.StringIO()
        with tarfile.open(fileobj=buffer, mode='w') as f:
            for member in self.members:
                basename = os.path.basename(member)
                f.add(member, arcname=basename)
        self.destination.write(buffer.getvalue())
        self.destination.close()

class PasswordEncrypter(threading.Thread):
    def __init__(self, destination, source, password):
        if not isinstance(destination, file):
            raise TypeError
        if not isinstance(source, file):
            raise TypeError
        if not isinstance(password, str):
            raise TypeError
        super(PasswordEncrypter, self).__init__()
        self.destination = destination
        self.source = source
        self.password = password

    def run(self):
        p = subprocess.Popen([gpg, '--symmetric', '--no-use-agent',
            '--passphrase', self.password], stdin=self.source,
            stdout=self.destination)
        p.wait()
        self.destination.close()

class Compressor(threading.Thread):
    def __init__(self, destination, source):
        if not isinstance(destination, file):
            raise TypeError
        if not isinstance(source, file):
            raise TypeError
        super(Compressor, self).__init__()
        self.destination = destination
        self.source = source

    def run(self):
        self.destination.write(lzma.compress(self.source.read()))
        self.destination.close()

def pipe():
    r, w = os.pipe()
    return os.fdopen(r, 'r'), os.fdopen(w, 'w')

def main(argv, out, err):
    parser = argparse.ArgumentParser(description="wrap a file for safe transmission")
    parser.add_argument('--input', '-i', default=[], required=True,
        action='append', help='input file or directory')
    parser.add_argument('--output', '-o', type=argparse.FileType('w'), help='output file')
    parser.add_argument('--compress', '-c', action='store_true', default=True,
        help='compress output')
    parser.add_argument('--no-compress', action='store_false', dest='compress',
        help='do not compress output')
    parser.add_argument('--password', '-p', help='password')
    opts = parser.parse_args(argv[1:])

    if opts.compress and lzma is None:
        print >>err, 'compression not available'
        return -1

    if opts.password is not None and gpg is None:
        print >>err, 'encryption not available'
        return -1

    wait_on = []
    name = [uuid.uuid4().hex]

    r, w = pipe()
    a = Archiver(w, opts.input)
    a.start()
    wait_on.append(a.join)
    tip = r
    name.append('tar')

    if opts.compress:
        r, w = pipe()
        c = Compressor(w, tip)
        c.start()
        wait_on.append(c.join)
        tip = r
        name.append('xz')

    if opts.password is not None:
        r, w = pipe()
        e = PasswordEncrypter(w, tip, opts.password)
        e.start()
        wait_on.append(e.join)
        tip = r
        name.append('gpg')

    if opts.output is None:
        output = open('.'.join(name), 'w')
    else:
        output = opts.output

    shutil.copyfileobj(tip, output)

    # Ensure the pipe is flushed.
    assert all(map(lambda x: hasattr(x, '__call__'), wait_on))
    [x() for x in wait_on]

    print 'created %s' % output.name

    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv, sys.stdout, sys.stderr))
