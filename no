#!/usr/bin/env python

'''
Sandboxing wrapper script
'''

import argparse
import os
import platform
import subprocess
import sys
import tempfile

def main(args):

  # parse command line options
  parser = argparse.ArgumentParser(description='process sandboxing utility')
  parser.add_argument('--no-network', action='store_true',
    help='disallow using networking')
  parser.add_argument('--no-reads', action='store_true',
    help='disallow file reading')
  parser.add_argument('--no-writes', action='store_true',
    help='disallow file writing')
  parser.add_argument('command', nargs=argparse.REMAINDER,
    help='command to run in sandbox')
  options = parser.parse_args(args[1:])

  if len(options.command) == 0:
    sys.stderr.write('no command provided\n')
    return -1

  # if no sandboxing was requested, just run the command
  if not any((options.no_network, options.no_reads, options.no_writes)):
    os.execvp(options.command[0], options.command)

  if platform.system() == 'Darwin': # Macos

    if options.no_network and not options.no_reads and not options.no_writes:
      os.execvp('sandbox-exec', ['sandbox-exec', '-n', 'no-network']
        + options.command)

    if not options.no_network and not options.no_reads and options.no_writes:
      os.execvp('sandbox-exec', ['sandbox-exec', '-n', 'no-write']
        + options.command)

    # otherwise we need to create a custom profile

    # create a suitable sandbox profile
    _, tmp = tempfile.mkstemp()
    with open(tmp, 'wt') as f:
      f.write('(version 1)\n'
              '(allow default)\n')

      if options.no_network:
        f.write('(deny network*)\n')
      if options.no_reads:
        f.write('(deny file-read*)\n'
                '(allow file-read* (regex "^/bin/.*"))\n'
                '(allow file-read* (regex "^/sbin/.*"))\n'
                '(allow file-read* (regex "^/System/.*"))\n'
                '(allow file-read* (regex "^/usr/.*"))\n')
      if options.no_writes:
        f.write('(deny file-write*)\n')

    # run the command
    ret = subprocess.call(['sandbox-exec', '-f', tmp] + options.command)

    # clean up
    os.remove(tmp)

    return ret

  else:
    sys.stderr.write('no sandboxing mechanism available\n')
    return -1


if __name__ == '__main__':
  sys.exit(main(sys.argv))
